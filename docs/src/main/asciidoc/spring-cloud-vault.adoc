= Spring Cloud Vault
:github: https://github.com/spring-cloud/spring-cloud-vault
:githubmaster: {github}/tree/master
:revnumber: {project-version}
:docslink: {githubmaster}/docs/src/main/asciidoc
:toc: left
:nofooter:

(C) 2016-2020 The original authors.

NOTE: _Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically._

include::intro.adoc[]

== Quick Start

include::quickstart.adoc[]

[[vault.config.authentication]]
== Authentication methods

Different organizations have different requirements for security and authentication.
Vault reflects that need by shipping multiple authentication methods.
Spring Cloud Vault supports token and AppId authentication.

[[vault.config.authentication.token]]
=== Token authentication

Tokens are the core method for authentication within Vault.
Token authentication requires a static token to be provided using the
https://github.com/spring-cloud/spring-cloud-commons/blob/master/docs/src/main/asciidoc/spring-cloud-commons.adoc#the-bootstrap-application-context[Bootstrap Application Context].

NOTE: Token authentication is the default authentication method.
If a token is disclosed an unintended party gains access to Vault and can access secrets for the intended client.

.bootstrap.yml
====
[source,yaml]
----
spring.cloud.vault:
    authentication: TOKEN
    token: 00000000-0000-0000-0000-000000000000
----
====

* `authentication` setting this value to `TOKEN` selects the Token authentication method
* `token` sets the static token to use

See also: https://www.vaultproject.io/docs/concepts/tokens.html[Vault Documentation: Tokens]

[[vault.config.authentication.vault-agent]]
=== Vault Agent authentication

Vault ships a sidecar utility with Vault Agent since version 0.11.0. Vault Agent implements the functionality of Spring Vault's `SessionManager`
with its Auto-Auth feature.
Applications can reuse cached session credentials by relying on Vault Agent running on `localhost`.
Spring Vault can send requests without the
`X-Vault-Token` header.
Disable Spring Vault's authentication infrastructure to disable client authentication and session management.

.bootstrap.yml
====
[source,yaml]
----
spring.cloud.vault:
    authentication: NONE
----
====

* `authentication` setting this value to `NONE` disables `ClientAuthentication`
and `SessionManager`.

See also: https://www.vaultproject.io/docs/agent/index.html[Vault Documentation: Agent]

[[vault.config.authentication.appid]]
=== AppId authentication

Vault supports https://www.vaultproject.io/docs/auth/app-id.html[AppId]
authentication that consists of two hard to guess tokens.
The AppId defaults to `spring.application.name` that is statically configured.
The second token is the UserId which is a part determined by the application, usually related to the runtime environment.
IP address, Mac address or a Docker container name are good examples.
Spring Cloud Vault Config supports IP address, Mac address and static UserId's (e.g. supplied via System properties).
The IP and Mac address are represented as Hex-encoded SHA256 hash.

IP address-based UserId's use the local host's IP address.

.bootstrap.yml using SHA256 IP-Address UserId's
====
[source,yaml]
----
spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: IP_ADDRESS
----
====

* `authentication` setting this value to `APPID` selects the AppId authentication method
* `app-id-path` sets the path of the AppId mount to use
* `user-id` sets the UserId method.
Possible values are `IP_ADDRESS`,
`MAC_ADDRESS` or a class name implementing a custom `AppIdUserIdMechanism`

The corresponding command to generate the IP address UserId from a command line is:

----
$ echo -n 192.168.99.1 | sha256sum
----

NOTE: Including the line break of `echo` leads to a different hash value so make sure to include the `-n` flag.

Mac address-based UserId's obtain their network device from the localhost-bound device.
The configuration also allows specifying a `network-interface` hint to pick the right device.
The value of
`network-interface` is optional and can be either an interface name or interface index (0-based).

.bootstrap.yml using SHA256 Mac-Address UserId's
====
[source,yaml]
----
spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: MAC_ADDRESS
        network-interface: eth0
----
====

* `network-interface` sets network interface to obtain the physical address


The corresponding command to generate the IP address UserId from a command line is:

----
$ echo -n 0AFEDE1234AC | sha256sum
----

NOTE: The Mac address is specified uppercase and without colons.
Including the line break of `echo` leads to a different hash value so make sure to include the `-n` flag.

==== Custom UserId

The UserId generation is an open mechanism.
You can set
`spring.cloud.vault.app-id.user-id` to any string and the configured value will be used as static UserId.

A more advanced approach lets you set `spring.cloud.vault.app-id.user-id` to a classname.
This class must be on your classpath and must implement the `org.springframework.cloud.vault.AppIdUserIdMechanism` interface and the `createUserId` method.
Spring Cloud Vault will obtain the UserId by calling `createUserId` each time it authenticates using AppId to obtain a token.

.bootstrap.yml
====
[source,yaml]
----
spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: com.examlple.MyUserIdMechanism
----
====

.MyUserIdMechanism.java
====
[source,yaml]
----
public class MyUserIdMechanism implements AppIdUserIdMechanism {

  @Override
  public String createUserId() {
    String userId = ...
    return userId;
  }
}
----
====

See also: https://www.vaultproject.io/docs/auth/app-id.html[Vault Documentation: Using the App ID auth backend]

=== AppRole authentication

https://www.vaultproject.io/docs/auth/app-id.html[AppRole] is intended for machine authentication, like the deprecated (since Vault 0.6.1) <<vault.config.authentication.appid>>.
AppRole authentication consists of two hard to guess (secret) tokens: RoleId and SecretId.

Spring Vault supports various AppRole scenarios (push/pull mode and wrapped).

RoleId and optionally SecretId must be provided by configuration, Spring Vault will not look up these or create a custom SecretId.

.bootstrap.yml with AppRole authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52
----
====

The following scenarios are supported along the required configuration details:

.Configuration
|===
| *Method*                          | *RoleId* | *SecretId*| *RoleName* | *Token*
| Provided RoleId/SecretId          | Provided | Provided  |            |
| Provided RoleId without SecretId  | Provided |           |            |
| Provided RoleId, Pull SecretId    | Provided | Provided  | Provided   | Provided
| Pull RoleId, provided SecretId    |          | Provided  | Provided   | Provided
| Full Pull Mode                    |          |           | Provided   | Provided
| Wrapped                           |          |           |            | Provided
| Wrapped RoleId, provided SecretId | Provided |           |            | Provided
| Provided RoleId, wrapped SecretId |          | Provided  |            | Provided
|===

.Pull/Push/Wrapped Matrix
|===
| *RoleId* | *SecretId* | *Supported*
| Provided | Provided   | ✅
| Provided | Pull       | ✅
| Provided | Wrapped    | ✅
| Provided | Absent     | ✅
| Pull     | Provided   | ✅
| Pull     | Pull       | ✅
| Pull     | Wrapped    | ❌
| Pull     | Absent     | ❌
| Wrapped  | Provided   | ✅
| Wrapped  | Pull       | ❌
| Wrapped  | Wrapped    | ✅
| Wrapped  | Absent     | ❌
|===

NOTE: You can use still all combinations of push/pull/wrapped modes by providing a configured `AppRoleAuthentication` bean within the bootstrap context.
Spring Cloud Vault cannot derive all possible AppRole combinations from the configuration properties.

IMPORTANT: AppRole authentication is limited to simple pull mode using reactive infrastructure.
Full pull mode is not yet supported.
Using Spring Cloud Vault with the Spring WebFlux stack enables Vault's reactive auto-configuration which can be disabled by setting `spring.cloud.vault.reactive.enabled=false`.

.bootstrap.yml with all AppRole authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52
        secret-id: 1696536f-1976-73b1-b241-0b4213908d39
        role: my-role
        app-role-path: approle
----
====

* `role-id` sets the RoleId.
* `secret-id` sets the SecretId.
SecretId can be omitted if AppRole is configured without requiring SecretId (See `bind_secret_id`).
* `role`: sets the AppRole name for pull mode.
* `app-role-path` sets the path of the approle authentication mount to use.

See also: https://www.vaultproject.io/docs/auth/approle.html[Vault Documentation: Using the AppRole auth backend]

[[vault.config.authentication.awsec2]]
=== AWS-EC2 authentication

The https://www.vaultproject.io/docs/auth/aws-ec2.html[aws-ec2]
auth backend provides a secure introduction mechanism for AWS EC2 instances, allowing automated retrieval of a Vault token.
Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.).
Instead, it treats AWS as a Trusted Third Party and uses the cryptographically signed dynamic metadata information that uniquely represents each EC2 instance.

.bootstrap.yml using AWS-EC2 Authentication
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AWS_EC2
----
====

AWS-EC2 authentication enables nonce by default to follow the Trust On First Use (TOFU) principle.
Any unintended party that gains access to the PKCS#7 identity metadata can authenticate against Vault.

During the first login, Spring Cloud Vault generates a nonce that is stored in the auth backend aside the instance Id.
Re-authentication requires the same nonce to be sent.
Any other party does not have the nonce and can raise an alert in Vault for further investigation.

The nonce is kept in memory and is lost during application restart.
You can configure a static nonce with `spring.cloud.vault.aws-ec2.nonce`.

AWS-EC2 authentication roles are optional and default to the AMI.
You can configure the authentication role by setting the
`spring.cloud.vault.aws-ec2.role` property.

.bootstrap.yml with configured role
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server
----
====

.bootstrap.yml with all AWS EC2 authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server
        aws-ec2-path: aws-ec2
        identity-document: http://...
        nonce: my-static-nonce
----
====

* `authentication` setting this value to `AWS_EC2` selects the AWS EC2 authentication method
* `role` sets the name of the role against which the login is being attempted.
* `aws-ec2-path` sets the path of the AWS EC2 mount to use
* `identity-document` sets URL of the PKCS#7 AWS EC2 identity document
* `nonce` used for AWS-EC2 authentication.
An empty nonce defaults to nonce generation

See also: https://www.vaultproject.io/docs/auth/aws.html[Vault Documentation: Using the aws auth backend]

[[vault.config.authentication.awsiam]]
=== AWS-IAM authentication

The https://www.vaultproject.io/docs/auth/aws-ec2.html[aws] backend provides a secure authentication mechanism for AWS IAM roles, allowing the automatic authentication with vault based on the current IAM role of the running application.
Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.).
Instead, it treats AWS as a Trusted Third Party and uses the 4 pieces of information signed by the caller with their IAM credentials to verify that the caller is indeed using that IAM role.

The current IAM role the application is running in is automatically calculated.
If you are running your application on AWS ECS then the application will use the IAM role assigned to the ECS task of the running container.
If you are running your application naked on top of an EC2 instance then the IAM role used will be the one assigned to the EC2 instance.

When using the AWS-IAM authentication you must create a role in Vault and assign it to your IAM role.
An empty `role` defaults to the friendly name the current IAM role.

.bootstrap.yml with required AWS-IAM Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AWS_IAM
----
====

.bootstrap.yml with all AWS-IAM Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AWS_IAM
    aws-iam:
        role: my-dev-role
        aws-path: aws
        server-name: some.server.name
        endpoint-uri: https://sts.eu-central-1.amazonaws.com
----
====

* `role` sets the name of the role against which the login is being attempted.
This should be bound to your IAM role.
If one is not supplied then the friendly name of the current IAM user will be used as the vault role.
* `aws-path` sets the path of the AWS mount to use
* `server-name` sets the value to use for the `X-Vault-AWS-IAM-Server-ID` header preventing certain types of replay attacks.
* `endpoint-uri` sets the value to use for the AWS STS API used for the `iam_request_url` parameter.

AWS-IAM requires the AWS Java SDK dependency (`com.amazonaws:aws-java-sdk-core`) as the authentication implementation uses AWS SDK types for credentials and request signing.

See also: https://www.vaultproject.io/docs/auth/aws.html[Vault Documentation: Using the aws auth backend]

[[vault.config.authentication.azuremsi]]
=== Azure MSI authentication

The https://www.vaultproject.io/docs/auth/azure.html[azure]
auth backend provides a secure introduction mechanism for Azure VM instances, allowing automated retrieval of a Vault token.
Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.).
Instead, it treats Azure as a Trusted Third Party and uses the managed service identity and instance metadata information that can be bound to a VM instance.

.bootstrap.yml with required Azure Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AZURE_MSI
    azure-msi:
        role: my-dev-role
----
====

.bootstrap.yml with all Azure Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: AZURE_MSI
    azure-msi:
        role: my-dev-role
        azure-path: azure
----
====

* `role` sets the name of the role against which the login is being attempted.
* `azure-path` sets the path of the Azure mount to use

Azure MSI authentication fetches environmental details about the virtual machine (subscription Id, resource group, VM name) from the instance metadata service.

See also: https://www.vaultproject.io/docs/auth/azure.html[Vault Documentation: Using the azure auth backend]

[[vault.config.authentication.clientcert]]
=== TLS certificate authentication

The `cert` auth backend allows authentication using SSL/TLS client certificates that are either signed by a CA or self-signed.

To enable `cert` authentication you need to:

1. Use SSL, see <<vault.config.ssl>>
2. Configure a Java `Keystore` that contains the client certificate and the private key
3. Set the `spring.cloud.vault.authentication` to `CERT`

.bootstrap.yml
====
[source,yaml]
----
spring.cloud.vault:
    authentication: CERT
    ssl:
        key-store: classpath:keystore.jks
        key-store-password: changeit
        cert-auth-path: cert
----
====

See also: https://www.vaultproject.io/docs/auth/cert.html[Vault Documentation: Using the Cert auth backend]

[[vault.config.authentication.cubbyhole]]
=== Cubbyhole authentication

Cubbyhole authentication uses Vault primitives to provide a secured authentication workflow.
Cubbyhole authentication uses tokens as primary login method.
An ephemeral token is used to obtain a second, login VaultToken from Vault's Cubbyhole secret backend.
The login token is usually longer-lived and used to interact with Vault.
The login token will be retrieved from a wrapped response stored at `/cubbyhole/response`.

*Creating a wrapped token*

NOTE: Response Wrapping for token creation requires Vault 0.6.0 or higher.

.Creating and storing tokens
====
[source,shell]
----
$ vault token-create -wrap-ttl="10m"
Key                            Value
---                            -----
wrapping_token:                397ccb93-ff6c-b17b-9389-380b01ca2645
wrapping_token_ttl:            0h10m0s
wrapping_token_creation_time:  2016-09-18 20:29:48.652957077 +0200 CEST
wrapped_accessor:              46b6aebb-187f-932a-26d7-4f3d86a68319
----
====

.bootstrap.yml
====
[source,yaml]
----
spring.cloud.vault:
    authentication: CUBBYHOLE
    token: 397ccb93-ff6c-b17b-9389-380b01ca2645
----
====

See also:

* https://www.vaultproject.io/docs/concepts/tokens.html[Vault Documentation: Tokens]
* https://www.vaultproject.io/docs/secrets/cubbyhole/index.html[Vault Documentation: Cubbyhole Secret Backend]
* https://www.vaultproject.io/docs/concepts/response-wrapping.html[Vault Documentation: Response Wrapping]

[[vault.config.authentication.gcpgce]]
=== GCP-GCE authentication

The https://www.vaultproject.io/docs/auth/gcp.html[gcp]
auth backend allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials.

GCP GCE (Google Compute Engine) authentication creates a signature in the form of a JSON Web Token (JWT) for a service account.
A JWT for a Compute Engine instance is obtained from the GCE metadata service using https://cloud.google.com/compute/docs/instances/verifying-instance-identity[Instance identification].
This API creates a JSON Web Token that can be used to confirm the instance identity.

Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.).
Instead, it treats GCP as a Trusted Third Party and uses the cryptographically signed dynamic metadata information that uniquely represents each GCP service account.

.bootstrap.yml with required GCP-GCE Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: GCP_GCE
    gcp-gce:
        role: my-dev-role
----
====

.bootstrap.yml with all GCP-GCE Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: GCP_GCE
    gcp-gce:
        gcp-path: gcp
        role: my-dev-role
        service-account: my-service@projectid.iam.gserviceaccount.com
----
====

* `role` sets the name of the role against which the login is being attempted.
* `gcp-path` sets the path of the GCP mount to use
* `service-account` allows overriding the service account Id to a specific value.
Defaults to the `default` service account.

See also:

* https://www.vaultproject.io/docs/auth/gcp.html[Vault Documentation: Using the GCP auth backend]
* https://cloud.google.com/compute/docs/instances/verifying-instance-identity[GCP Documentation: Verifying the Identity of Instances]

[[vault.config.authentication.gcpiam]]
=== GCP-IAM authentication

The https://www.vaultproject.io/docs/auth/gcp.html[gcp]
auth backend allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials.

GCP IAM authentication creates a signature in the form of a JSON Web Token (JWT) for a service account.
A JWT for a service account is obtained by calling GCP IAM's https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt[`projects.serviceAccounts.signJwt`] API. The caller authenticates against GCP IAM and proves thereby its identity.
This Vault backend treats GCP as a Trusted Third Party.

IAM credentials can be obtained from either the runtime environment , specifically the https://cloud.google.com/docs/authentication/production[`GOOGLE_APPLICATION_CREDENTIALS`]
environment variable, the Google Compute metadata service, or supplied externally as e.g. JSON or base64 encoded.
JSON is the preferred form as it carries the project id and service account identifier required for calling ``projects.serviceAccounts.signJwt``.

.bootstrap.yml with required GCP-IAM Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: GCP_IAM
    gcp-iam:
        role: my-dev-role
----
====

.bootstrap.yml with all GCP-IAM Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: GCP_IAM
    gcp-iam:
        credentials:
            location: classpath:credentials.json
            encoded-key: e+KApn0=
        gcp-path: gcp
        jwt-validity: 15m
        project-id: my-project-id
        role: my-dev-role
        service-account-id: my-service@projectid.iam.gserviceaccount.com
----
====

* `role` sets the name of the role against which the login is being attempted.
* `credentials.location` path to the credentials resource that contains Google credentials in JSON format.
* `credentials.encoded-key` the base64 encoded contents of an OAuth2 account private key in the JSON format.
* `gcp-path` sets the path of the GCP mount to use
* `jwt-validity` configures the JWT token validity.
Defaults to 15 minutes.
* `project-id` allows overriding the project Id to a specific value.
Defaults to the project Id from the obtained credential.
* `service-account` allows overriding the service account Id to a specific value.
Defaults to the service account from the obtained credential.

GCP IAM authentication requires the Google Cloud Java SDK dependency (`com.google.apis:google-api-services-iam` and `com.google.auth:google-auth-library-oauth2-http`) as the authentication implementation uses Google APIs for credentials and JWT signing.

NOTE: Google credentials require an OAuth 2 token maintaining the token lifecycle.
All API is synchronous therefore, `GcpIamAuthentication` does not support `AuthenticationSteps` which is required for reactive usage.

See also:

* https://www.vaultproject.io/docs/auth/gcp.html[Vault Documentation: Using the GCP auth backend]
* https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt[GCP Documentation: projects.serviceAccounts.signJwt]

[[vault.authentication.gcpiam]]

[[vault.config.authentication.kubernetes]]
=== Kubernetes authentication

Kubernetes authentication mechanism (since Vault 0.8.3) allows to authenticate with Vault using a Kubernetes Service Account Token.
The authentication is role based and the role is bound to a service account name and a namespace.

A file containing a JWT token for a pod’s service account is automatically mounted at `/var/run/secrets/kubernetes.io/serviceaccount/token`.

.bootstrap.yml with all Kubernetes authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: KUBERNETES
    kubernetes:
        role: my-dev-role
        kubernetes-path: kubernetes
        service-account-token-file: /var/run/secrets/kubernetes.io/serviceaccount/token
----
====

* `role` sets the Role.
* `kubernetes-path` sets the path of the Kubernetes mount to use.
* `service-account-token-file` sets the location of the file containing the Kubernetes Service Account Token.
Defaults to `/var/run/secrets/kubernetes.io/serviceaccount/token`.

See also:

* https://www.vaultproject.io/docs/auth/kubernetes.html[Vault Documentation: Kubernetes]
* https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[Kubernetes Documentation: Configure Service Accounts for Pods]

[[vault.config.authentication.pcf]]
=== Pivotal CloudFoundry authentication

The https://www.vaultproject.io/docs/auth/pcf.html[pcf]
auth backend provides a secure introduction mechanism for applications running within Pivotal's CloudFoundry instances allowing automated retrieval of a Vault token.
Unlike most Vault authentication backends, this backend does not require first-deploying, or provisioning security-sensitive credentials (tokens, username/password, client certificates, etc.) as identity provisioning is handled by PCF itself.
Instead, it treats PCF as a Trusted Third Party and uses the managed instance identity.

.bootstrap.yml with required PCF Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: PCF
    pcf:
        role: my-dev-role
----
====

.bootstrap.yml with all PCF Authentication properties
====
[source,yaml]
----
spring.cloud.vault:
    authentication: PCF
    pcf:
        role: my-dev-role
        pcf-path: path
        instance-certificate: /etc/cf-instance-credentials/instance.crt
        instance-key: /etc/cf-instance-credentials/instance.key
----
====

* `role` sets the name of the role against which the login is being attempted.
* `pcf-path` sets the path of the PCF mount to use.
* `instance-certificate` sets the path to the PCF instance identity certificate.
Defaults to `${CF_INSTANCE_CERT}` env variable.
* `instance-key` sets the path to the PCF instance identity key.
Defaults to `${CF_INSTANCE_KEY}` env variable.

NOTE: PCF authentication requires BouncyCastle (bcpkix-jdk15on) to be on the classpath for RSA PSS signing.

See also: https://www.vaultproject.io/docs/auth/pcf.html[Vault Documentation: Using the pcf auth backend]

[[vault.config.backends]]
== Secret Backends

[[vault.config.backends.kv]]
[[vault.config.backends.generic]]
[[vault.config.backends.kv.versioned]]
=== Key-Value Backend

Spring Cloud Vault supports both Key-Value secret backends, the versioned (v2) and unversioned (v1).
The key-value backend allows storage of arbitrary values as key-value store.
A single context can store one or many key-value tuples.
Contexts can be organized hierarchically.
Spring Cloud Vault determines itself whether a secret is using versioning and maps the path to its appropriate URL.
Spring Cloud Vault allows using the Application name and a default context name (`application`) in combination with active profiles.

----
/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}
----

The application name is determined by the properties:

* `spring.cloud.vault.kv.application-name`
* `spring.cloud.vault.application-name`
* `spring.application.name`

The profiles are determined by the properties:

* `spring.cloud.vault.kv.profiles`
* `spring.profiles.active`

Secrets can be obtained from other contexts within the key-value backend by adding their paths to the application name, separated by commas.
For example, given the application name `usefulapp,mysql1,projectx/aws`, each of these folders will be used:

* `/secret/usefulapp`
* `/secret/mysql1`
* `/secret/projectx/aws`

Spring Cloud Vault adds all active profiles to the list of possible context paths.
No active profiles will skip accessing contexts with a profile name.

Properties are exposed like they are stored (i.e. without additional prefixes).

NOTE: Spring Cloud Vault adds the `data/` context between the mount path and the actual context path depending on whether the mount uses the versioned key-value backend.

====
[source,yaml]
----
spring.cloud.vault:
    kv:
        enabled: true
        backend: secret
        profile-separator: '/'
        default-context: application
        application-name: my-app
        profiles: local, cloud
----
====

* `enabled` setting this value to `false` disables the secret backend config usage
* `backend` sets the path of the secret mount to use
* `default-context` sets the context name used by all applications
* `application-name` overrides the application name for use in the key-value backend
* `profiles` overrides the active profiles for use in the key-value backend
* `profile-separator` separates the profile name from the context in property sources with profiles

NOTE: The key-value secret backend can be operated in versioned (v2) and non-versioned (v1) modes.

See also:

* https://www.vaultproject.io/docs/secrets/kv/kv-v1.html[Vault Documentation: Using the KV Secrets Engine - Version 1 (generic secret backend)]
* https://www.vaultproject.io/docs/secrets/kv/kv-v2.html[Vault Documentation: Using the KV Secrets Engine - Version 2 (versioned key-value backend)]

[[vault.config.backends.consul]]
=== Consul

Spring Cloud Vault can obtain credentials for HashiCorp Consul.
The Consul integration requires the `spring-cloud-vault-config-consul`
dependency.

.pom.xml
====
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-consul</artifactId>
        <version>{project-version}</version>
    </dependency>
</dependencies>
----
====

The integration can be enabled by setting
`spring.cloud.vault.consul.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.consul.role=…`.

The obtained token is stored in `spring.cloud.consul.token`
so using Spring Cloud Consul can pick up the generated credentials without further configuration.
You can configure the property name by setting `spring.cloud.vault.consul.token-property`.

====
[source,yaml]
----
spring.cloud.vault:
    consul:
        enabled: true
        role: readonly
        backend: consul
        token-property: spring.cloud.consul.token
----
====

* `enabled` setting this value to `true` enables the Consul backend config usage
* `role` sets the role name of the Consul role definition
* `backend` sets the path of the Consul mount to use
* `token-property` sets the property name in which the Consul ACL token is stored

See also: https://www.vaultproject.io/docs/secrets/consul/index.html[Vault Documentation: Setting up Consul with Vault]

[[vault.config.backends.rabbitmq]]
=== RabbitMQ

Spring Cloud Vault can obtain credentials for RabbitMQ.

The RabbitMQ integration requires the `spring-cloud-vault-config-rabbitmq`
dependency.

.pom.xml
====
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-rabbitmq</artifactId>
        <version>{project-version}</version>
    </dependency>
</dependencies>
----
====

The integration can be enabled by setting
`spring.cloud.vault.rabbitmq.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.rabbitmq.role=…`.

Username and password are stored in `spring.rabbitmq.username`
and `spring.rabbitmq.password` so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting `spring.cloud.vault.rabbitmq.username-property` and
`spring.cloud.vault.rabbitmq.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    rabbitmq:
        enabled: true
        role: readonly
        backend: rabbitmq
        username-property: spring.rabbitmq.username
        password-property: spring.rabbitmq.password
----
====

* `enabled` setting this value to `true` enables the RabbitMQ backend config usage
* `role` sets the role name of the RabbitMQ role definition
* `backend` sets the path of the RabbitMQ mount to use
* `username-property` sets the property name in which the RabbitMQ username is stored
* `password-property` sets the property name in which the RabbitMQ password is stored

See also: https://www.vaultproject.io/docs/secrets/rabbitmq/index.html[Vault Documentation: Setting up RabbitMQ with Vault]

[[vault.config.backends.aws]]
=== AWS

Spring Cloud Vault can obtain credentials for AWS.

The AWS integration requires the `spring-cloud-vault-config-aws`
dependency.

.pom.xml
====
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-aws</artifactId>
        <version>{project-version}</version>
    </dependency>
</dependencies>
----
====

The integration can be enabled by setting
`spring.cloud.vault.aws=true` (default `false`) and providing the role name with `spring.cloud.vault.aws.role=…`.

The access key and secret key are stored in `cloud.aws.credentials.accessKey`
and `cloud.aws.credentials.secretKey` so using Spring Cloud AWS will pick up the generated credentials without further configuration.
You can configure the property names by setting `spring.cloud.vault.aws.access-key-property` and
`spring.cloud.vault.aws.secret-key-property`.

====
[source,yaml]
----
spring.cloud.vault:
    aws:
        enabled: true
        role: readonly
        backend: aws
        access-key-property: cloud.aws.credentials.accessKey
        secret-key-property: cloud.aws.credentials.secretKey
----
====

* `enabled` setting this value to `true` enables the AWS backend config usage
* `role` sets the role name of the AWS role definition
* `backend` sets the path of the AWS mount to use
* `access-key-property` sets the property name in which the AWS access key is stored
* `secret-key-property` sets the property name in which the AWS secret key is stored

See also: https://www.vaultproject.io/docs/secrets/aws/index.html[Vault Documentation: Setting up AWS with Vault]

[[vault.config.backends.database-backends]]
== Database backends

Vault supports several database secret backends to generate database credentials dynamically based on configured roles.
This means services that need to access a database no longer need to configure credentials: they can request them from Vault, and use Vault's leasing mechanism to more easily roll keys.

Spring Cloud Vault integrates with these backends:

* <<vault.config.backends.database>>
* <<vault.config.backends.cassandra>>
* <<vault.config.backends.elasticsearch>>
* <<vault.config.backends.mongodb>>
* <<vault.config.backends.mysql>>
* <<vault.config.backends.postgresql>>

Using a database secret backend requires to enable the backend in the configuration and the `spring-cloud-vault-config-databases`
dependency.

Vault ships since 0.7.1 with a dedicated `database` secret backend that allows database integration via plugins.
You can use that specific backend by using the generic database backend.
Make sure to specify the appropriate backend path, e.g. `spring.cloud.vault.mysql.role.backend=database`.

.pom.xml
====
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-databases</artifactId>
        <version>{project-version}</version>
    </dependency>
</dependencies>
----
====

NOTE: Enabling multiple JDBC-compliant databases will generate credentials and store them by default in the same property keys hence property names for JDBC secrets need to be configured separately.

[[vault.config.backends.database]]
=== Database

Spring Cloud Vault can obtain credentials for any database listed at
https://www.vaultproject.io/api/secret/databases/index.html.
The integration can be enabled by setting
`spring.cloud.vault.database.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.database.role=…`.

While the database backend is a generic one, `spring.cloud.vault.database`
specifically targets JDBC databases.
Username and password are available from `spring.datasource.username` and `spring.datasource.password` properties
so using Spring Boot will pick up the generated credentials for your `DataSource` without further configuration.
You can configure the property names by setting
`spring.cloud.vault.database.username-property` and
`spring.cloud.vault.database.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    database:
        enabled: true
        role: readonly
        backend: database
        username-property: spring.datasource.username
        password-property: spring.datasource.password
----
====

* `enabled` setting this value to `true` enables the Database backend config usage
* `role` sets the role name of the Database role definition
* `backend` sets the path of the Database mount to use
* `username-property` sets the property name in which the Database username is stored
* `password-property` sets the property name in which the Database password is stored

See also: https://www.vaultproject.io/docs/secrets/databases/index.html[Vault Documentation: Database Secrets backend]

WARNING: Spring Cloud Vault does not support getting new credentials and configuring your `DataSource` with them when the maximum lease time has been reached.
That is, if `max_ttl` of the Database role in Vault is set to `24h` that means that 24 hours after your application has started it can no longer authenticate with the database.

[[vault.config.backends.cassandra]]
=== Apache Cassandra

NOTE: The `cassandra` backend has been deprecated in Vault 0.7.1 and it is recommended to use the `database` backend and mount it as `cassandra`.

Spring Cloud Vault can obtain credentials for Apache Cassandra.
The integration can be enabled by setting
`spring.cloud.vault.cassandra.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.cassandra.role=…`.

Username and password are available from `spring.data.cassandra.username`
and `spring.data.cassandra.password` properties so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting
`spring.cloud.vault.cassandra.username-property` and
`spring.cloud.vault.cassandra.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    cassandra:
        enabled: true
        role: readonly
        backend: cassandra
        username-property: spring.data.cassandra.username
        password-property: spring.data.cassandra.password
----
====

* `enabled` setting this value to `true` enables the Cassandra backend config usage
* `role` sets the role name of the Cassandra role definition
* `backend` sets the path of the Cassandra mount to use
* `username-property` sets the property name in which the Cassandra username is stored
* `password-property` sets the property name in which the Cassandra password is stored

See also: https://www.vaultproject.io/docs/secrets/cassandra/index.html[Vault Documentation: Setting up Apache Cassandra with Vault]

[[vault.config.backends.elasticsearch]]
=== Elasticsearch

Spring Cloud Vault can obtain since version 3.0 credentials for Elasticsearch.
The integration can be enabled by setting
`spring.cloud.vault.elasticsearch.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.elasticsearch.role=…`.

Username and password are available from `spring.elasticsearch.rest.username`
and `spring.elasticsearch.rest.password` properties so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting
`spring.cloud.vault.elasticsearch.username-property` and
`spring.cloud.vault.elasticsearch.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    elasticsearch:
        enabled: true
        role: readonly
        backend: mongodb
        username-property: spring.elasticsearch.rest.username
        password-property: spring.elasticsearch.rest.password
----
====

* `enabled` setting this value to `true` enables the Elasticsearch database backend config usage
* `role` sets the role name of the Elasticsearch role definition
* `backend` sets the path of the Elasticsearch mount to use
* `username-property` sets the property name in which the Elasticsearch username is stored
* `password-property` sets the property name in which the Elasticsearch password is stored

See also: https://www.vaultproject.io/docs/secrets/databases/elasticdb[Vault Documentation: Setting up Elasticsearch with Vault]

[[vault.config.backends.mongodb]]
=== MongoDB

NOTE: The `mongodb` backend has been deprecated in Vault 0.7.1 and it is recommended to use the `database` backend and mount it as `mongodb`.

Spring Cloud Vault can obtain credentials for MongoDB.
The integration can be enabled by setting
`spring.cloud.vault.mongodb.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.mongodb.role=…`.

Username and password are stored in `spring.data.mongodb.username`
and `spring.data.mongodb.password` so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting
`spring.cloud.vault.mongodb.username-property` and
`spring.cloud.vault.mongodb.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    mongodb:
        enabled: true
        role: readonly
        backend: mongodb
        username-property: spring.data.mongodb.username
        password-property: spring.data.mongodb.password
----
====

* `enabled` setting this value to `true` enables the MongodB backend config usage
* `role` sets the role name of the MongoDB role definition
* `backend` sets the path of the MongoDB mount to use
* `username-property` sets the property name in which the MongoDB username is stored
* `password-property` sets the property name in which the MongoDB password is stored

See also: https://www.vaultproject.io/docs/secrets/mongodb/index.html[Vault Documentation: Setting up MongoDB with Vault]

[[vault.config.backends.mysql]]
=== MySQL

NOTE: The `mysql` backend has been deprecated in Vault 0.7.1 and it is recommended to use the `database` backend and mount it as `mysql`.
Configuration for `spring.cloud.vault.mysql` will be removed in a future version.

Spring Cloud Vault can obtain credentials for MySQL.
The integration can be enabled by setting
`spring.cloud.vault.mysql.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.mysql.role=…`.

Username and password are available from `spring.datasource.username`
and `spring.datasource.password` properties so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting
`spring.cloud.vault.mysql.username-property` and
`spring.cloud.vault.mysql.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    mysql:
        enabled: true
        role: readonly
        backend: mysql
        username-property: spring.datasource.username
        password-property: spring.datasource.password
----
====

* `enabled` setting this value to `true` enables the MySQL backend config usage
* `role` sets the role name of the MySQL role definition
* `backend` sets the path of the MySQL mount to use
* `username-property` sets the property name in which the MySQL username is stored
* `password-property` sets the property name in which the MySQL password is stored

See also: https://www.vaultproject.io/docs/secrets/mysql/index.html[Vault Documentation: Setting up MySQL with Vault]

[[vault.config.backends.postgresql]]
=== PostgreSQL

NOTE: The `postgresql` backend has been deprecated in Vault 0.7.1 and it is recommended to use the `database` backend and mount it as `postgresql`.
Configuration for `spring.cloud.vault.postgresql` will be removed in a future version.

Spring Cloud Vault can obtain credentials for PostgreSQL.
The integration can be enabled by setting
`spring.cloud.vault.postgresql.enabled=true` (default `false`) and providing the role name with `spring.cloud.vault.postgresql.role=…`.

Username and password are available from `spring.datasource.username`
and `spring.datasource.password` properties so using Spring Boot will pick up the generated credentials without further configuration.
You can configure the property names by setting
`spring.cloud.vault.postgresql.username-property` and
`spring.cloud.vault.postgresql.password-property`.

====
[source,yaml]
----
spring.cloud.vault:
    postgresql:
        enabled: true
        role: readonly
        backend: postgresql
        username-property: spring.datasource.username
        password-property: spring.datasource.password
----
====

* `enabled` setting this value to `true` enables the PostgreSQL backend config usage
* `role` sets the role name of the PostgreSQL role definition
* `backend` sets the path of the PostgreSQL mount to use
* `username-property` sets the property name in which the PostgreSQL username is stored
* `password-property` sets the property name in which the PostgreSQL password is stored

See also: https://www.vaultproject.io/docs/secrets/postgresql/index.html[Vault Documentation: Setting up PostgreSQL with Vault]

[[vault.config.backends.configurer]]
== Configure `PropertySourceLocator` behavior

Spring Cloud Vault uses property-based configuration to create ``PropertySource``s for key-value and discovered secret backends.

Discovered backends provide `VaultSecretBackendDescriptor` beans to describe the configuration state to use secret backend as `PropertySource`.
A `SecretBackendMetadataFactory` is required to create a `SecretBackendMetadata` object which contains path, name and property transformation configuration.

`SecretBackendMetadata` is used to back a particular `PropertySource`.

You can register an arbitrary number of beans implementing `VaultConfigurer` for customization.
Default key-value and discovered backend registration is disabled if Spring Cloud Vault discovers at least one `VaultConfigurer` bean.
You can however enable default registration with
`SecretBackendConfigurer.registerDefaultKeyValueSecretBackends()` and `SecretBackendConfigurer.registerDefaultDiscoveredSecretBackends()`.

====
[source,java]
----
public class CustomizationBean implements VaultConfigurer {

    @Override
    public void addSecretBackends(SecretBackendConfigurer configurer) {

        configurer.add("secret/my-application");

        configurer.registerDefaultKeyValueSecretBackends(false);
        configurer.registerDefaultDiscoveredSecretBackends(true);
    }
}
----
====

NOTE: All customization is required to happen in the bootstrap context.
Add your configuration classes to `META-INF/spring.factories` at `org.springframework.cloud.bootstrap.BootstrapConfiguration`
in your application.

== Service Registry Configuration

You can use a `DiscoveryClient` (such as from Spring Cloud Consul) to locate a Vault server by setting spring.cloud.vault.discovery.enabled=true (default `false`).
The net result of that is that your apps need a bootstrap.yml (or an environment variable) with the appropriate discovery configuration.
The benefit is that the Vault can change its co-ordinates, as long as the discovery service is a fixed point.
The default service id is `vault` but you can change that on the client with
`spring.cloud.vault.discovery.serviceId`.

The discovery client implementations all support some kind of metadata map (e.g. for Eureka we have eureka.instance.metadataMap).
Some additional properties of the service may need to be configured in its service registration metadata so that clients can connect correctly.
Service registries that do not provide details about transport layer security need to provide a `scheme` metadata entry to be set either to `https` or `http`.
If no scheme is configured and the service is not exposed as secure service, then configuration defaults to `spring.cloud.vault.scheme` which is `https` when it's not set.

====
[source,yaml]
----
spring.cloud.vault.discovery:
    enabled: true
    service-id: my-vault-service
----
====

[[vault.config.fail-fast]]
== Vault Client Fail Fast

In some cases, it may be desirable to fail startup of a service if it cannot connect to the Vault Server.
If this is the desired behavior, set the bootstrap configuration property
`spring.cloud.vault.fail-fast=true` and the client will halt with an Exception.

====
[source,yaml]
----
spring.cloud.vault:
    fail-fast: true
----
====

[[vault.config.namespaces]]
== Vault Enterprise Namespace Support

Vault Enterprise allows using namespaces to isolate multiple Vaults on a single Vault server.
Configuring a namespace by setting
`spring.cloud.vault.namespace=…` enables the namespace header
`X-Vault-Namespace` on every outgoing HTTP request when using the Vault
`RestTemplate` or `WebClient`.

Please note that this feature is not supported by Vault Community edition and has no effect on Vault operations.

====
[source,yaml]
----
spring.cloud.vault:
    namespace: my-namespace
----
====

See also: https://www.vaultproject.io/docs/enterprise/namespaces/index.html[Vault Enterprise: Namespaces]

[[vault.config.ssl]]
== Vault Client SSL configuration

SSL can be configured declaratively by setting various properties.
You can set either `javax.net.ssl.trustStore` to configure JVM-wide SSL settings or `spring.cloud.vault.ssl.trust-store`
to set SSL settings only for Spring Cloud Vault Config.

====
[source,yaml]
----
spring.cloud.vault:
    ssl:
        trust-store: classpath:keystore.jks
        trust-store-password: changeit
----
====

* `trust-store` sets the resource for the trust-store.
SSL-secured Vault communication will validate the Vault SSL certificate with the specified trust-store.
* `trust-store-password` sets the trust-store password


Please note that configuring `spring.cloud.vault.ssl.*` can be only applied when either Apache Http Components or the OkHttp client is on your class-path.

[[vault-lease-renewal]]
== Lease lifecycle management (renewal and revocation)

With every secret, Vault creates a lease:
metadata containing information such as a time duration, renewability, and more.

Vault promises that the data will be valid for the given duration, or Time To Live (TTL).
Once the lease is expired, Vault can revoke the data, and the consumer of the secret can no longer be certain that it is valid.

Spring Cloud Vault maintains a lease lifecycle beyond the creation of login tokens and secrets.
That said, login tokens and secrets associated with a lease are scheduled for renewal just before the lease expires until terminal expiry.
Application shutdown revokes obtained login tokens and renewable leases.

Secret service and database backends (such as MongoDB or MySQL) usually generate a renewable lease so generated credentials will be disabled on application shutdown.

NOTE: Static tokens are not renewed or revoked.

Lease renewal and revocation is enabled by default and can be disabled by setting `spring.cloud.vault.config.lifecycle.enabled`
to `false`.
This is not recommended as leases can expire and Spring Cloud Vault cannot longer access Vault or services using generated credentials and valid credentials remain active after application shutdown.

====
[source,yaml]
----
spring.cloud.vault:
    config.lifecycle:
    	enabled: true
    	min-renewal: 10s
    	expiry-threshold: 1m
    	lease-endpoints: Legacy

----
====

* `enabled` controls whether leases associated with secrets are considered to be renewed and expired secrets are rotated.
Enabled by default.
* `min-renewal` sets the duration that is at least required before renewing a lease.
This setting prevents renewals from happening too often.
* `expiry-threshold` sets the expiry threshold.
A lease is renewed the configured period of time before it expires.
* `lease-endpoints` sets the endpoints for renew and revoke.
Legacy for vault versions before 0.8 and SysLeases for later.

See also: https://www.vaultproject.io/docs/concepts/lease.html[Vault Documentation: Lease, Renew, and Revoke]

[[vault-session-lifecycle]]
== Session token lifecycle management (renewal, re-login and revocation)

A Vault session token (also referred to as `LoginToken`) is quite similar to a lease as it has a TTL, max TTL, and may expire.
Once a login token expires, it cannot be used anymore to interact with Vault.
Therefore, Spring Vault ships with a `SessionManager` API for imperative and reactive use.

Spring Cloud Vault maintains the session token lifecycle by default.
Session tokens are obtained lazily so the actual login is deferred until the first session-bound use of Vault.
Once Spring Cloud Vault obtains a session token, it retains it until expiry.
The next time a session-bound activity is used, Spring Cloud Vault re-logins into Vault and obtains a new session token.
On application shut down, Spring Cloud Vault revokes the token if it was still active to terminate the session.

Session lifecycle is enabled by default and can be disabled by setting `spring.cloud.vault.session.lifecycle.enabled`
to `false`.
Disabling is not recommended as session tokens can expire and Spring Cloud Vault cannot longer access Vault.

====
[source,yaml]
----
spring.cloud.vault:
    session.lifecycle:
        enabled: true
        refresh-before-expiry: 10s
        expiry-threshold: 20s
----
====

* `enabled` controls whether session lifecycle management is enabled to renew session tokens.
Enabled by default.
* `refresh-before-expiry` controls the point in time when the session token gets renewed.
The refresh time is calculated by subtracting `refresh-before-expiry` from the token expiry time.
Defaults to `5 seconds`.
* `expiry-threshold` sets the expiry threshold.
The threshold represents a minimum TTL duration to consider a session token as valid.
Tokens with a shorter TTL are considered expired and are not used anymore.
Should be greater than  `refresh-before-expiry` to prevent token expiry.
Defaults to `7 seconds`.

See also: https://www.vaultproject.io/api-docs/auth/token#renew-a-token-self[Vault Documentation: Token Renewal]
